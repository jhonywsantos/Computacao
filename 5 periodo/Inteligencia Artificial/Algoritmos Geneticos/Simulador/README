# Algoritmos Genéticos: Otimização de Rotas

Este projeto apresenta a implementação de um **Algoritmo Genético (AG)** aplicado ao **Problema do Caixeiro Viajante (PCV)**, com **visualização aprimorada** do processo evolutivo.  
O código foi desenvolvido utilizando **Processing** no modo **Python**, permitindo acompanhamento em tempo real da otimização das rotas.

---

## 📋 Objetivo
Aplicar técnicas de **Inteligência Computacional** para encontrar rotas eficientes que minimizem a distância total percorrida, explorando:
- Seleção por roleta
- Crossover do tipo *Order Crossover (OX)*
- Mutação por troca de posições
- Elitismo
- Visualização gráfica do progresso

---

## 🧠 Descrição do Problema
O **Problema do Caixeiro Viajante (PCV)** consiste em encontrar a menor rota que passe por todas as cidades exatamente uma vez e retorne à origem.  
Trata-se de um problema **NP-difícil**, com grande relevância em logística, transporte e redes de comunicação.

---

## ⚙️ Métodos Utilizados
1. **Codificação da Solução:** Representação das rotas como listas ordenadas de cidades.
2. **Função de Avaliação (Fitness):** Distância total inversa usando a fórmula da distância euclidiana.
3. **Seleção:** Roleta ponderada pelo *fitness*.
4. **Crossover:** Ordem preservada (*Order Crossover – OX*).
5. **Mutação:** Troca aleatória de cidades (20% de taxa).
6. **Elitismo:** Preservação dos melhores indivíduos.

---

## 🖥️ Estrutura do Código
- **Configuração inicial:** Parâmetros, número de cidades, população inicial.
- **Algoritmo genético:** Ciclo de evolução com seleção, cruzamento, mutação e elitismo.
- **Visualização:** Interface gráfica mostrando cidades, rotas, evolução do *fitness* e animação de transições.

---

## 🎨 Visualização
O sistema apresenta:
- **Mapa das cidades** (pontos verdes)
- **Rotas por indivíduo** (cores e espessuras diferentes)
- **Gráfico de evolução** do *fitness* médio e do melhor indivíduo
- **Animação suave** entre gerações
- **Destaque da melhor rota final**

---

## 📊 Resultados Obtidos
- **Geração inicial:** Fitness ≈ 5,62 (rotas aleatórias)
- **Geração 17:** Fitness ≈ 9,00 (rotas mais otimizadas)
- **Geração final (35):** Fitness = 10,38, rota:  
  `B → A → D → E → I → H → J → F → C → G`

O algoritmo demonstrou melhora significativa em poucas gerações.

---

## 📦 Requisitos
- **Processing** instalado
- Ativar **Python Mode** no Processing
- Executar o código `.pyde` fornecido

---

## 🚀 Como Executar
1. Abra o **Processing** e altere para o **Python Mode**.
2. Carregue o arquivo do código.
3. Pressione `Espaço` para iniciar a evolução.
4. Pressione `R` ou clique com o mouse para reiniciar a simulação.

---

## 📚 Referências
- Soares et al. (2023) – *Um algoritmo genético híbrido para o problema do caixeiro viajante com tempos de liberação*
- Gonçalves et al. (2020) – *Algoritmo genético aplicado ao problema de roteamento de veículos*
- Braga & Droguett (2007) – *Modelagem e otimização do problema do caixeiro viajante*
- Ramos (2005) – *Metodologia estatística na solução do problema do caixeiro viajante*
- Applegate et al. (2006) – *The Travelling Salesman Problem: A Computational Study*
- Bäck (1996) – *Evolutionary Algorithms in Theory and Practice*
- Costa et al. (2003) – *SLAG – Resolvendo o problema do caixeiro viajante utilizando algoritmos genéticos*
- Cunha et al. (2002) – *Experimentos computacionais com heurísticas de melhorias para o problema do caixeiro viajante*

---

## 👥 Autores
- [Igor Silva](https://github.com/Southcruz)
- [Jhony Wictor](https://github.com/jhonywsantos)  
- [Karleandro Silva](https://github.com/karleandrosilva)  
- [Lucas Farias](https://github.com/LucaRosendo)

**Universidade Federal de Alagoas – Campus Arapiraca**  
Bacharelado em Ciência da Computação – Turma CPTA126-01 2025.1
